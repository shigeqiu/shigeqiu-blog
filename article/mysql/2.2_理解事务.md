# MySQL 事务
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [MySQL 事务](#mysql-事务)
	- [概述](#概述)
	- [ACID](#acid)
	- [语法](#语法)
	- [四种隔离级别](#四种隔离级别)
	- [事务的并发问题](#事务的并发问题)
		- [脏写](#脏写)
		- [脏读](#脏读)
		- [不可重复读](#不可重复读)
		- [幻读](#幻读)

<!-- /TOC -->

## 概述

> MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关

1. MyISAM：不支持事务，用于只读程序提高性能
1. InnoDB：支持ACID事务、行级锁、并发
1. Berkeley DB：支持事务


## ACID

1. 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
1. 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
1. 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
1. 持久性（Durability）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 语法

- 开启事务`START TRANSACTION 或 BEGIN`
- 提交事务（关闭事务）`COMMIT`
- 放弃事务（关闭事务）`ROLLBACK`
- 折返点

 ```sql
   SAVEPOINT adqoo_1
   ROLLBACK TO SAVEPOINT adqoo_1
   -- 发生在折返点 adqoo_1 之前的事务被提交，之后的被忽略
```
- 事务终止
- 还有一点需要注意，**就是事务只针对当前连接。**

## 四种隔离级别

- **Read Uncommitted（读取未提交内容）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，
因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
- **Read Committed（读取提交内容）**

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。
它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

- **Repeatable Read（可重读）**

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，
另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

- **Serializable（可串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。


## 事务的并发问题

1. 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，
由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
1. 不可重复读(Non-repeatable read)【更新提交后】:在一个事务的两次查询之中数据不一致，
这可能是两次查询过程中间插入了一个事务更新的原有的数据。
1. 幻读(Phantom Read)【插入提交后】:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，
而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。


### 脏写

>【下文中我们会常常采用这样的表示格式，w1(x=2)表示事务1对x这个数据做了一个w操作（写操作），将x的值改成了2】



某个事务对数据x做了写入操作，在本事务结束前，另一个事务也对x做了写操作。
怎么就脏了？



**场景1**

假设有个一致性约束叫做数据x必须等于数据y。两个并发的事务都按照这个约束去写数据

事务 |||| | 提交
---|---|---|---|---|---
T1  | w1(x=1) | | | w1(y=1) | c1   
T2  |   | w2(x=2) | w2(y=2)  || c2


示例中的两个都事务逻辑都在保证x=y（一个打算让x=y=1，另一个打算让x=y=2），但是最终提交后，x=2,y=1，不满足x=y的约束了。

**场景2**

约束更简单：只要修改x，它就必须被修改成2

事务| 初始(x=0) |x=2|x=2|回滚(x=0) | 提交(x=0)
---|---|---|---|---|---
T1 | | w1(x=2) | |a1 |   
T2 | |   | w2(x=2) | | c2


这里a1代表事务1做了a操作（abort操作/回滚操作），c2代表事务2做了c操作（commit操作）。

例子说明：
- 事务1把x置为了2，接着心情突然不好，回滚了。它想起将x修改为2之前其值是0，要回滚嘛，于是就把值修改回了0。
- 事务2把x修改成了2，高兴地提交了，然后一看，x等于0，没有没修改成2

### 脏读
事务1对x做了写操作，在事务1结束前，事务2对x做了读操作。
怎么就脏了？

**场景**

x账户转账1块钱给y账户，初始值：x=0，y=0

事务 | x账户+1 |  读x账户 | 回滚|转账操作| 提交
--- | --- | ---| --- |--- | ---
T1  |  w1(x=1) | | a1 | |
T2  |   |  r2(x=1) ||w2(y=1;x=0)| c2

转账的约束很显然是x+y不变。这个例子里，由于数据只有一份，事务2读到了事务1未提交的值（x=1），没想事务1接下来回滚了，回滚后x这唯一一份数据从1改回了0，没毛病。但是事务2接着做转账了，x减1，y加1，然后提交，也没毛病。但是最终的结果x+y变了。

脏在事务2“读”到了一个不存在的值（x=1），是为脏读。避免了脏读，隔离级别就从READ-UNCOMMITTED升级到了READ-COMMITTED。
### 不可重复读
一个事务读取了x的值，在结束前，另一个事务又去写了x。
为什么就不可重复了？

**场景**

事务 | 读取账户 |  x账户+2 | y账户-2 |提交| 读取y账户 | 提交
--- | --- | --- | --- | --- | --- | ---
T1  | r1(x=10)  |   |   || r1(y=8) | c1
T2  | r2(x=10,y=10) | w2(x=12) | w2(y=8) |c2||   

约束是x+y值恒为20，然而该示例中，事务1看到的x+y=18，不满足约束。即，一旦“一个事务读取了x的值，在结束前允许了另一个事务又去写x”，就会造成不一致。

读者一定会问：为什么叫“不可重复读”？上述示例中x没有在一个事务中被重复度过啊。这个是SQL-92最原始的定义是“事务重复两次读取x之间x被另一个事务写”，后续演进了一版变成了本文的样子。怎么演进的本文不讨论了，姑且这么理解吧：一旦允许“一个事务读取了x的值，在结束前允许了另一个事务又去写x”这种情况发生，事务1在事务2提交后再去读x时，就会看到和首次读不同的值，所以失去了重复读的能力。

### 幻读

一个事务读了一个谓词（人话转述是“读了where条件的判定结果或者执行了一次where条件判断”）后，在完成前，另一个事务对满足此谓词的某条数据做了写（人话转述是“插入了一条满足前面where条件的新数据、从满足前面where条件的数据里删除了一条、将不满足前面where条件的数据改得满足、将满足前面where条件的某条数据改成不满足”）。

> 和不可重复读的区别就是：把x（具体记录）换成了谓词。

** 场景**  

 事务 | 读苹果表个数| 往苹果表+1 | 读摘要个数 | 摘要记录+1 | 提交| 读取了一下摘要  | 提交
 --- | --- |---|---|---|---|---|---
T1  | r1(count)  | | |  || r1(abstr)|  c1
T2  |  |w2(insert) | r2(abstr) | w2(abstr+1) | c2 ||

假设有两张表：苹果表、苹果表的摘要表。苹果表的一行记录代表一个苹果，摘要表(abstr)只有一行记录，就是苹果表的行数，即苹果总数。

一致性约束：摘要表唯一一行记录的值必须等于苹果表的行数。

初始状态：苹果表有10行，摘要表记录取值10。

事务1读了一个苹果表的谓词（select count(\*) from 苹果表 where true，谓词是true），事务2在事务1完成前又插入了一条满足谓词true的记录。触发了幻读：

- 事务2看到的故事是：我往苹果表insert了一行记录，然后打算给摘要表记录做个加1操作（首先读取摘要记录，在为读到的摘要记录+1然后写会摘要记录），此时摘要表记录值是11，然后提交。事务2没毛病：保持了摘要值和苹果表记录数都是11，一致的；
- 事务1看到的故事：我count了一下苹果表（谓词很简单，直接是true），看到是10，然后我读取了一下摘要表，看到的是11。不一致！我Phatom了！

所以幻读不好，因为它会破坏一致性。为了升级为更高的隔离级别SERIALIZABLE，避免幻读是必要条件（按照SQL-92的意思，也是充分条件）。
