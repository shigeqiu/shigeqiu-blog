# 多版本并发控制MVVC

<!-- TOC -->

- [多版本并发控制MVVC](#多版本并发控制mvvc)
    - [什么是当前读和快照读？](#什么是当前读和快照读)
    - [当前读，快照读和MVCC的关系](#当前读快照读和mvcc的关系)
    - [MVCC能解决什么问题，好处是？](#mvcc能解决什么问题好处是)
    - [快照读和当前读](#快照读和当前读)
    - [锁定读](#锁定读)
    - [一致性非锁定读](#一致性非锁定读)

<!-- /TOC -->

> MVCC，全称 `Multi-Version Concurrency Control` ，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。


> https://blog.csdn.net/SnailMann/article/details/94724197

## 什么是当前读和快照读？

在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?

- **当前读**
像 `select lock in share mode` (`共享锁`), select for update ; update, insert ,delete(`排他锁`)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

- **快照读**
像 `不加锁` 的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是 `快照读` , 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。**

## 当前读，快照读和MVCC的关系


- 准确的说，MVCC多版本并发控制指的是 **“维持一个数据的多个版本，使得读写操作没有冲突”** 这么一个概念。仅仅是一个理想概念
- 而在MySQL中，实现这么一个MVCC理想概念，**我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能**。而相对而言，当前读就是悲观锁的具体功能实现
- 要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 `3个隐式字段`，`undo日志` ，`Read View` 等去完成的，具体可以看下面的MVCC实现原理


## MVCC能解决什么问题，好处是？

数据库并发场景有三种，分别为：

- 读-读：不存在任何问题，也不需要并发控制
- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
- 
MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决 `读-写冲突` 的 **无锁并发控制**，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以 **在数据库中，因为有了MVCC，所以我们可以形成两个组合：**

- `MVCC + 悲观锁` MVCC解决读写冲突，悲观锁解决写写冲突
- `MVCC + 乐观锁` MVCC解决读写冲突，乐观锁解决写写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

---

这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。这项技术在数据库领域并不是普遍使用的。一些其它的数据库产品，以及mysql其它的存储引擎并不支持它。

mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能。

什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，

而每一个事务在启动的时候，都有一个唯一的递增的版本号。 

在InnoDB中，给每行增加两个隐藏字段来实现MVCC，两个列都用来存储事务的版本号，每开启一个新事务，事务的版本号就会递增。

于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT
  - 读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT
  - 将当前事务的版本号保存至行的创建版本号
- UPDATE
  - 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE
  - 将当前事务的版本号保存至行的删除版本号


在插入操作时 ： 记录的创建版本号就是事务版本号。 

比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。

| id | name      | create version | delete version |
|----|-----------|----------------|----------------|
| 1  | `xttblog` | 1              |                |

在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。 

``` sql
update table set name= 'new_value' where id=1;
```

| id | name          | create version | delete version |
|----|---------------|----------------|----------------|
| 1  | `xttblog`     | 1              | 2              |
| 1  | `xttblog.com` | 2              |                |

删除操作的时候，就把事务版本号作为删除版本号。比如：

``` sql
delete from table where id=1;
```

| id | name          | create version | delete version |
|----|---------------|----------------|----------------|
| 1  | `xttblog.com` | 2              | 3              |

查询操作：从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来： 

1. 删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。 
2. 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前。

这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：通过版本号来减少锁的争用。另外，只有read-committed和 repeatable-read 两种事务隔离级别才能使用mvcc， read-uncommited由于是读到未提交的，所以不存在版本的问题。而serializable 则会对所有读取的行加锁。 

## 快照读和当前读

- 快照读：读取的是快照版本，也就是历史版本
- 当前读：读取的是最新版本

普通的`SELECT`就是快照读，而`UPDATE`、`DELETE`、`INSERT`、`SELECT …  LOCK IN SHARE MODE`、`SELECT … FOR UPDATE`是当前读。

## 锁定读

在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。

``` sql
SELECT ... LOCK IN SHARE MODE
```

给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交

``` sql
SELECT ... FOR UPDATE
```

给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的

## 一致性非锁定读

consistent read （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。

MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题。