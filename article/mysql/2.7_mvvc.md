# 多版本并发控制MVVC

MVCC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。这项技术在数据库领域并不是普遍使用的。一些其它的数据库产品，以及mysql其它的存储引擎并不支持它。

mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能。

什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，

而每一个事务在启动的时候，都有一个唯一的递增的版本号。 

在InnoDB中，给每行增加两个隐藏字段来实现MVCC，两个列都用来存储事务的版本号，每开启一个新事务，事务的版本号就会递增。

于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT
  - 读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT
  - 将当前事务的版本号保存至行的创建版本号
- UPDATE
  - 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE
  - 将当前事务的版本号保存至行的删除版本号


在插入操作时 ： 记录的创建版本号就是事务版本号。 

比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。

| id | name      | create version | delete version |
|----|-----------|----------------|----------------|
| 1  | `xttblog` | 1              |                |

在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。 

``` sql
update table set name= 'new_value' where id=1;
```

| id | name          | create version | delete version |
|----|---------------|----------------|----------------|
| 1  | `xttblog`     | 1              | 2              |
| 1  | `xttblog.com` | 2              |                |

删除操作的时候，就把事务版本号作为删除版本号。比如：

``` sql
delete from table where id=1;
```

| id | name          | create version | delete version |
|----|---------------|----------------|----------------|
| 1  | `xttblog.com` | 2              | 3              |

查询操作：从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来： 

1. 删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。 
1. 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前。

这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是：通过版本号来减少锁的争用。另外，只有read-committed和 repeatable-read 两种事务隔离级别才能使用mvcc， read-uncommited由于是读到未提交的，所以不存在版本的问题。而serializable 则会对所有读取的行加锁。 

## 快照读和当前读

- 快照读：读取的是快照版本，也就是历史版本
- 当前读：读取的是最新版本

普通的`SELECT`就是快照读，而`UPDATE`、`DELETE`、`INSERT`、`SELECT …  LOCK IN SHARE MODE`、`SELECT … FOR UPDATE`是当前读。

## 锁定读

在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。

``` sql
SELECT ... LOCK IN SHARE MODE
```

给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交

``` sql
SELECT ... FOR UPDATE
```

给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的

## 一致性非锁定读

consistent read （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。

MVCC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题。